---
title: 'Beads: A Memory System for AI Coding Agents'
description: 'Published December 7, 2025'
---

Steve Yegge's new project, [Beads](https://github.com/steveyegge/beads), tackles
a fundamental problem with AI coding agents: they forget everything between
sessions.

You've probably experienced this. You're deep into a complex refactor with
Claude Code, making great progress. The agent discovers three related bugs along
the way, mentions them in passing, then... the session ends. The next day, you
start fresh, and all that context is gone. The bugs are forgotten. The mental
map of the codebase evaporates.

Beads gives your agent a persistent memory.

---

## What Beads Actually Is

Beads is a distributed issue tracker designed specifically for AI agents. But
calling it an "issue tracker" undersells it. It's closer to an external memory
system that happens to store work items.

The clever part is how it works. There's no server, no database to set up. Beads
stores everything in a `.beads/` directory as JSONL files, synced through Git.
When you clone a repo with Beads, you get the full "database" automatically. A
local SQLite cache provides fast queries, with automatic syncing between the
cache and the JSONL source of truth.

```bash
bd init            # One-time setup
bd create "Fix auth bug"  # Agent files an issue
bd ready --json    # Agent queries for unblocked work
bd close bd-a1b2   # Agent marks work complete
```

The `--json` flag throughout makes it trivial for agents to work with
programmatically. No CLI output parsing needed.

## Why Agents Need This

Yegge describes the problem well: agents are "wildly productive junior
developers" who are "potentially whacked out on mind-altering drugs." They're
fast and enthusiastic but prone to forgetting what they just told you.

The issue isn't intelligence. It's that LLMs have no persistent state. Every new
session starts from scratch. Your agent might have done brilliant exploratory
work yesterday, discovered edge cases, noted technical debt, formed a mental
model of the system, and today it knows none of it.

Markdown planning files help, but they collapse under complexity. Nested
dependencies become impossible to track. What work is actually unblocked? What
depends on what? Markdown can't tell you.

Beads models work as a graph with four types of dependencies:

- **Blocks**: Hard dependency (can't start until resolved)
- **Related**: Soft link (connected but non-blocking)
- **Parent-child**: Hierarchical breakdown
- **Discovered-from**: Provenance tracking

The `bd ready` command does the useful thing: it finds issues with no blocking
dependencies. Your agent starts each session by querying what's actually
actionable.

## The Workflow Inversion

The interesting design decision is _who_ uses Beads. It's not primarily for
humans.

Traditional issue trackers are human-facing tools that agents might occasionally
query. Beads inverts this. Agents are the primary users. They file issues for
themselves and their future sessions. They discover bugs during refactoring and
immediately log them. They break down epics into tasks. They track their own
progress.

Yegge recommends putting this in your agent configuration:

```markdown
## Issue Tracking

Use `bd quickstart` for a full tutorial. For discovered bugs, TODOs, and
follow-up tasks, file them immediately with `bd create`. Before ending a
session, sync all local issues.
```

The human's job becomes simpler: run `bd init` once, then occasionally review
what the agents have been tracking. The agents handle the bookkeeping.

## Hash IDs and Multi-Agent Workflows

One subtle but important detail: Beads uses hash-based IDs (`bd-a1b2`, `bd-f14c`)
instead of sequential numbers (`bd-1`, `bd-2`).

Why does this matter? Concurrent agents.

If you have multiple agents working in different branches (Yegge describes
running four agents simultaneously), sequential IDs would constantly conflict at
merge time. Two agents both creating issue #5 is a problem. Two agents creating
`bd-a1b2` and `bd-f14c` is fine.

The hash length scales with database size (4 → 5 → 6 characters) using birthday
paradox math to keep collisions rare. It's the kind of detail that sounds boring
until you've lost work to a merge conflict.

## The Broader Pattern

Beads reflects a larger shift in how we work with AI agents. The agent isn't
just a code generator you prompt when you need something. It's a collaborator
with memory, context, and ongoing work.

Yegge's workflow involves never talking directly to agents. Instead, you "talk
to the plan": update a Markdown file that serves as a contract, and let agents
reference it. Plans expose agent intentions before execution, letting you
correct course before wasted work. Each workstream maintains its own plan.

Beads extends this to task tracking. The agent reads the plan, queries
`bd ready` for unblocked work, executes, updates progress, files newly
discovered issues, and persists everything before the session ends.

This is infrastructure for treating agents as persistent team members rather
than stateless tools.

## Getting Started

```bash
# Install
brew install steveyegge/beads/bd   # macOS
# or download from GitHub releases

# Initialize in your repo
bd init

# Show your agent the ropes
bd quickstart
```

The [GitHub repo](https://github.com/steveyegge/beads) has full documentation.
Community tools like `beads-ui` and VS Code extensions have already emerged.

The project is alpha-status with expected API changes before 1.0, but the core
functionality is solid. Yegge "vibe coded" it from concept to a thousand GitHub
stars in six days, which says something about both the tool and the demand it's
addressing.

## Worth Trying If...

You're doing multi-session work with AI agents. The more complex and
long-running your projects, the more value you'll get from giving your agents
persistent memory. If you've ever wished your agent remembered what it
discovered yesterday, Beads is worth a look.
